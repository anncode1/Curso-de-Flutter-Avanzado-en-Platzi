/*
 * Copyright 2018 Google
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: google/firestore/v1/firestore.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/Empty.pbobjc.h>
 #import <Protobuf/Timestamp.pbobjc.h>
#else
 #import "Empty.pbobjc.h"
 #import "Timestamp.pbobjc.h"
#endif

 #import "Firestore.pbobjc.h"
 #import "Annotations.pbobjc.h"
 #import "Common.pbobjc.h"
 #import "Document.pbobjc.h"
 #import "Query.pbobjc.h"
 #import "Write.pbobjc.h"
 #import "Status.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#pragma clang diagnostic ignored "-Wdirect-ivar-access"

#pragma mark - GCFSFirestoreRoot

@implementation GCFSFirestoreRoot


@end

#pragma mark - GCFSFirestoreRoot_FileDescriptor

static GPBFileDescriptor *GCFSFirestoreRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"google.firestore.v1"
                                                 objcPrefix:@"GCFS"
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - GCFSGetDocumentRequest

@implementation GCFSGetDocumentRequest

@dynamic consistencySelectorOneOfCase;
@dynamic name;
@dynamic hasMask, mask;
@dynamic transaction;
@dynamic readTime;

typedef struct GCFSGetDocumentRequest__storage_ {
  uint32_t _has_storage_[2];
  NSString *name;
  GCFSDocumentMask *mask;
  NSData *transaction;
  GPBTimestamp *readTime;
} GCFSGetDocumentRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = GCFSGetDocumentRequest_FieldNumber_Name,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GCFSGetDocumentRequest__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "mask",
        .dataTypeSpecific.className = GPBStringifySymbol(GCFSDocumentMask),
        .number = GCFSGetDocumentRequest_FieldNumber_Mask,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GCFSGetDocumentRequest__storage_, mask),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "transaction",
        .dataTypeSpecific.className = NULL,
        .number = GCFSGetDocumentRequest_FieldNumber_Transaction,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(GCFSGetDocumentRequest__storage_, transaction),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "readTime",
        .dataTypeSpecific.className = GPBStringifySymbol(GPBTimestamp),
        .number = GCFSGetDocumentRequest_FieldNumber_ReadTime,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(GCFSGetDocumentRequest__storage_, readTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GCFSGetDocumentRequest class]
                                     rootClass:[GCFSFirestoreRoot class]
                                          file:GCFSFirestoreRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GCFSGetDocumentRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    static const char *oneofs[] = {
      "consistencySelector",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void GCFSGetDocumentRequest_ClearConsistencySelectorOneOfCase(GCFSGetDocumentRequest *message) {
  GPBDescriptor *descriptor = [message descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBMaybeClearOneof(message, oneof, -1, 0);
}
#pragma mark - GCFSListDocumentsRequest

@implementation GCFSListDocumentsRequest

@dynamic consistencySelectorOneOfCase;
@dynamic parent;
@dynamic collectionId;
@dynamic pageSize;
@dynamic pageToken;
@dynamic orderBy;
@dynamic hasMask, mask;
@dynamic transaction;
@dynamic readTime;
@dynamic showMissing;

typedef struct GCFSListDocumentsRequest__storage_ {
  uint32_t _has_storage_[2];
  int32_t pageSize;
  NSString *parent;
  NSString *collectionId;
  NSString *pageToken;
  NSString *orderBy;
  GCFSDocumentMask *mask;
  NSData *transaction;
  GPBTimestamp *readTime;
} GCFSListDocumentsRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "parent",
        .dataTypeSpecific.className = NULL,
        .number = GCFSListDocumentsRequest_FieldNumber_Parent,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GCFSListDocumentsRequest__storage_, parent),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "collectionId",
        .dataTypeSpecific.className = NULL,
        .number = GCFSListDocumentsRequest_FieldNumber_CollectionId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GCFSListDocumentsRequest__storage_, collectionId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "pageSize",
        .dataTypeSpecific.className = NULL,
        .number = GCFSListDocumentsRequest_FieldNumber_PageSize,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GCFSListDocumentsRequest__storage_, pageSize),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "pageToken",
        .dataTypeSpecific.className = NULL,
        .number = GCFSListDocumentsRequest_FieldNumber_PageToken,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(GCFSListDocumentsRequest__storage_, pageToken),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "orderBy",
        .dataTypeSpecific.className = NULL,
        .number = GCFSListDocumentsRequest_FieldNumber_OrderBy,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(GCFSListDocumentsRequest__storage_, orderBy),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "mask",
        .dataTypeSpecific.className = GPBStringifySymbol(GCFSDocumentMask),
        .number = GCFSListDocumentsRequest_FieldNumber_Mask,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(GCFSListDocumentsRequest__storage_, mask),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "transaction",
        .dataTypeSpecific.className = NULL,
        .number = GCFSListDocumentsRequest_FieldNumber_Transaction,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(GCFSListDocumentsRequest__storage_, transaction),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "readTime",
        .dataTypeSpecific.className = GPBStringifySymbol(GPBTimestamp),
        .number = GCFSListDocumentsRequest_FieldNumber_ReadTime,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(GCFSListDocumentsRequest__storage_, readTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "showMissing",
        .dataTypeSpecific.className = NULL,
        .number = GCFSListDocumentsRequest_FieldNumber_ShowMissing,
        .hasIndex = 6,
        .offset = 7,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GCFSListDocumentsRequest class]
                                     rootClass:[GCFSFirestoreRoot class]
                                          file:GCFSFirestoreRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GCFSListDocumentsRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    static const char *oneofs[] = {
      "consistencySelector",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void GCFSListDocumentsRequest_ClearConsistencySelectorOneOfCase(GCFSListDocumentsRequest *message) {
  GPBDescriptor *descriptor = [message descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBMaybeClearOneof(message, oneof, -1, 0);
}
#pragma mark - GCFSListDocumentsResponse

@implementation GCFSListDocumentsResponse

@dynamic documentsArray, documentsArray_Count;
@dynamic nextPageToken;

typedef struct GCFSListDocumentsResponse__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *documentsArray;
  NSString *nextPageToken;
} GCFSListDocumentsResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "documentsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(GCFSDocument),
        .number = GCFSListDocumentsResponse_FieldNumber_DocumentsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GCFSListDocumentsResponse__storage_, documentsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "nextPageToken",
        .dataTypeSpecific.className = NULL,
        .number = GCFSListDocumentsResponse_FieldNumber_NextPageToken,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GCFSListDocumentsResponse__storage_, nextPageToken),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GCFSListDocumentsResponse class]
                                     rootClass:[GCFSFirestoreRoot class]
                                          file:GCFSFirestoreRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GCFSListDocumentsResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GCFSCreateDocumentRequest

@implementation GCFSCreateDocumentRequest

@dynamic parent;
@dynamic collectionId;
@dynamic documentId;
@dynamic hasDocument, document;
@dynamic hasMask, mask;

typedef struct GCFSCreateDocumentRequest__storage_ {
  uint32_t _has_storage_[1];
  NSString *parent;
  NSString *collectionId;
  NSString *documentId;
  GCFSDocument *document;
  GCFSDocumentMask *mask;
} GCFSCreateDocumentRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "parent",
        .dataTypeSpecific.className = NULL,
        .number = GCFSCreateDocumentRequest_FieldNumber_Parent,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GCFSCreateDocumentRequest__storage_, parent),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "collectionId",
        .dataTypeSpecific.className = NULL,
        .number = GCFSCreateDocumentRequest_FieldNumber_CollectionId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GCFSCreateDocumentRequest__storage_, collectionId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "documentId",
        .dataTypeSpecific.className = NULL,
        .number = GCFSCreateDocumentRequest_FieldNumber_DocumentId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GCFSCreateDocumentRequest__storage_, documentId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "document",
        .dataTypeSpecific.className = GPBStringifySymbol(GCFSDocument),
        .number = GCFSCreateDocumentRequest_FieldNumber_Document,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(GCFSCreateDocumentRequest__storage_, document),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "mask",
        .dataTypeSpecific.className = GPBStringifySymbol(GCFSDocumentMask),
        .number = GCFSCreateDocumentRequest_FieldNumber_Mask,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(GCFSCreateDocumentRequest__storage_, mask),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GCFSCreateDocumentRequest class]
                                     rootClass:[GCFSFirestoreRoot class]
                                          file:GCFSFirestoreRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GCFSCreateDocumentRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GCFSUpdateDocumentRequest

@implementation GCFSUpdateDocumentRequest

@dynamic hasDocument, document;
@dynamic hasUpdateMask, updateMask;
@dynamic hasMask, mask;
@dynamic hasCurrentDocument, currentDocument;

typedef struct GCFSUpdateDocumentRequest__storage_ {
  uint32_t _has_storage_[1];
  GCFSDocument *document;
  GCFSDocumentMask *updateMask;
  GCFSDocumentMask *mask;
  GCFSPrecondition *currentDocument;
} GCFSUpdateDocumentRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "document",
        .dataTypeSpecific.className = GPBStringifySymbol(GCFSDocument),
        .number = GCFSUpdateDocumentRequest_FieldNumber_Document,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GCFSUpdateDocumentRequest__storage_, document),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "updateMask",
        .dataTypeSpecific.className = GPBStringifySymbol(GCFSDocumentMask),
        .number = GCFSUpdateDocumentRequest_FieldNumber_UpdateMask,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GCFSUpdateDocumentRequest__storage_, updateMask),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "mask",
        .dataTypeSpecific.className = GPBStringifySymbol(GCFSDocumentMask),
        .number = GCFSUpdateDocumentRequest_FieldNumber_Mask,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GCFSUpdateDocumentRequest__storage_, mask),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "currentDocument",
        .dataTypeSpecific.className = GPBStringifySymbol(GCFSPrecondition),
        .number = GCFSUpdateDocumentRequest_FieldNumber_CurrentDocument,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(GCFSUpdateDocumentRequest__storage_, currentDocument),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GCFSUpdateDocumentRequest class]
                                     rootClass:[GCFSFirestoreRoot class]
                                          file:GCFSFirestoreRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GCFSUpdateDocumentRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GCFSDeleteDocumentRequest

@implementation GCFSDeleteDocumentRequest

@dynamic name;
@dynamic hasCurrentDocument, currentDocument;

typedef struct GCFSDeleteDocumentRequest__storage_ {
  uint32_t _has_storage_[1];
  NSString *name;
  GCFSPrecondition *currentDocument;
} GCFSDeleteDocumentRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = GCFSDeleteDocumentRequest_FieldNumber_Name,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GCFSDeleteDocumentRequest__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "currentDocument",
        .dataTypeSpecific.className = GPBStringifySymbol(GCFSPrecondition),
        .number = GCFSDeleteDocumentRequest_FieldNumber_CurrentDocument,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GCFSDeleteDocumentRequest__storage_, currentDocument),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GCFSDeleteDocumentRequest class]
                                     rootClass:[GCFSFirestoreRoot class]
                                          file:GCFSFirestoreRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GCFSDeleteDocumentRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GCFSBatchGetDocumentsRequest

@implementation GCFSBatchGetDocumentsRequest

@dynamic consistencySelectorOneOfCase;
@dynamic database;
@dynamic documentsArray, documentsArray_Count;
@dynamic hasMask, mask;
@dynamic transaction;
@dynamic newTransaction;
@dynamic readTime;

typedef struct GCFSBatchGetDocumentsRequest__storage_ {
  uint32_t _has_storage_[2];
  NSString *database;
  NSMutableArray *documentsArray;
  GCFSDocumentMask *mask;
  NSData *transaction;
  GCFSTransactionOptions *newTransaction;
  GPBTimestamp *readTime;
} GCFSBatchGetDocumentsRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "database",
        .dataTypeSpecific.className = NULL,
        .number = GCFSBatchGetDocumentsRequest_FieldNumber_Database,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GCFSBatchGetDocumentsRequest__storage_, database),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "documentsArray",
        .dataTypeSpecific.className = NULL,
        .number = GCFSBatchGetDocumentsRequest_FieldNumber_DocumentsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GCFSBatchGetDocumentsRequest__storage_, documentsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "mask",
        .dataTypeSpecific.className = GPBStringifySymbol(GCFSDocumentMask),
        .number = GCFSBatchGetDocumentsRequest_FieldNumber_Mask,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GCFSBatchGetDocumentsRequest__storage_, mask),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "transaction",
        .dataTypeSpecific.className = NULL,
        .number = GCFSBatchGetDocumentsRequest_FieldNumber_Transaction,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(GCFSBatchGetDocumentsRequest__storage_, transaction),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "newTransaction",
        .dataTypeSpecific.className = GPBStringifySymbol(GCFSTransactionOptions),
        .number = GCFSBatchGetDocumentsRequest_FieldNumber_NewTransaction,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(GCFSBatchGetDocumentsRequest__storage_, newTransaction),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "readTime",
        .dataTypeSpecific.className = GPBStringifySymbol(GPBTimestamp),
        .number = GCFSBatchGetDocumentsRequest_FieldNumber_ReadTime,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(GCFSBatchGetDocumentsRequest__storage_, readTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GCFSBatchGetDocumentsRequest class]
                                     rootClass:[GCFSFirestoreRoot class]
                                          file:GCFSFirestoreRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GCFSBatchGetDocumentsRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    static const char *oneofs[] = {
      "consistencySelector",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void GCFSBatchGetDocumentsRequest_ClearConsistencySelectorOneOfCase(GCFSBatchGetDocumentsRequest *message) {
  GPBDescriptor *descriptor = [message descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBMaybeClearOneof(message, oneof, -1, 0);
}
#pragma mark - GCFSBatchGetDocumentsResponse

@implementation GCFSBatchGetDocumentsResponse

@dynamic resultOneOfCase;
@dynamic found;
@dynamic missing;
@dynamic transaction;
@dynamic hasReadTime, readTime;

typedef struct GCFSBatchGetDocumentsResponse__storage_ {
  uint32_t _has_storage_[2];
  GCFSDocument *found;
  NSString *missing;
  NSData *transaction;
  GPBTimestamp *readTime;
} GCFSBatchGetDocumentsResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "found",
        .dataTypeSpecific.className = GPBStringifySymbol(GCFSDocument),
        .number = GCFSBatchGetDocumentsResponse_FieldNumber_Found,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(GCFSBatchGetDocumentsResponse__storage_, found),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "missing",
        .dataTypeSpecific.className = NULL,
        .number = GCFSBatchGetDocumentsResponse_FieldNumber_Missing,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(GCFSBatchGetDocumentsResponse__storage_, missing),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "transaction",
        .dataTypeSpecific.className = NULL,
        .number = GCFSBatchGetDocumentsResponse_FieldNumber_Transaction,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GCFSBatchGetDocumentsResponse__storage_, transaction),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "readTime",
        .dataTypeSpecific.className = GPBStringifySymbol(GPBTimestamp),
        .number = GCFSBatchGetDocumentsResponse_FieldNumber_ReadTime,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GCFSBatchGetDocumentsResponse__storage_, readTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GCFSBatchGetDocumentsResponse class]
                                     rootClass:[GCFSFirestoreRoot class]
                                          file:GCFSFirestoreRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GCFSBatchGetDocumentsResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    static const char *oneofs[] = {
      "result",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void GCFSBatchGetDocumentsResponse_ClearResultOneOfCase(GCFSBatchGetDocumentsResponse *message) {
  GPBDescriptor *descriptor = [message descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBMaybeClearOneof(message, oneof, -1, 0);
}
#pragma mark - GCFSBeginTransactionRequest

@implementation GCFSBeginTransactionRequest

@dynamic database;
@dynamic hasOptions, options;

typedef struct GCFSBeginTransactionRequest__storage_ {
  uint32_t _has_storage_[1];
  NSString *database;
  GCFSTransactionOptions *options;
} GCFSBeginTransactionRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "database",
        .dataTypeSpecific.className = NULL,
        .number = GCFSBeginTransactionRequest_FieldNumber_Database,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GCFSBeginTransactionRequest__storage_, database),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "options",
        .dataTypeSpecific.className = GPBStringifySymbol(GCFSTransactionOptions),
        .number = GCFSBeginTransactionRequest_FieldNumber_Options,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GCFSBeginTransactionRequest__storage_, options),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GCFSBeginTransactionRequest class]
                                     rootClass:[GCFSFirestoreRoot class]
                                          file:GCFSFirestoreRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GCFSBeginTransactionRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GCFSBeginTransactionResponse

@implementation GCFSBeginTransactionResponse

@dynamic transaction;

typedef struct GCFSBeginTransactionResponse__storage_ {
  uint32_t _has_storage_[1];
  NSData *transaction;
} GCFSBeginTransactionResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "transaction",
        .dataTypeSpecific.className = NULL,
        .number = GCFSBeginTransactionResponse_FieldNumber_Transaction,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GCFSBeginTransactionResponse__storage_, transaction),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GCFSBeginTransactionResponse class]
                                     rootClass:[GCFSFirestoreRoot class]
                                          file:GCFSFirestoreRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GCFSBeginTransactionResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GCFSCommitRequest

@implementation GCFSCommitRequest

@dynamic database;
@dynamic writesArray, writesArray_Count;
@dynamic transaction;

typedef struct GCFSCommitRequest__storage_ {
  uint32_t _has_storage_[1];
  NSString *database;
  NSMutableArray *writesArray;
  NSData *transaction;
} GCFSCommitRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "database",
        .dataTypeSpecific.className = NULL,
        .number = GCFSCommitRequest_FieldNumber_Database,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GCFSCommitRequest__storage_, database),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "writesArray",
        .dataTypeSpecific.className = GPBStringifySymbol(GCFSWrite),
        .number = GCFSCommitRequest_FieldNumber_WritesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GCFSCommitRequest__storage_, writesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "transaction",
        .dataTypeSpecific.className = NULL,
        .number = GCFSCommitRequest_FieldNumber_Transaction,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GCFSCommitRequest__storage_, transaction),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GCFSCommitRequest class]
                                     rootClass:[GCFSFirestoreRoot class]
                                          file:GCFSFirestoreRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GCFSCommitRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GCFSCommitResponse

@implementation GCFSCommitResponse

@dynamic writeResultsArray, writeResultsArray_Count;
@dynamic hasCommitTime, commitTime;

typedef struct GCFSCommitResponse__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *writeResultsArray;
  GPBTimestamp *commitTime;
} GCFSCommitResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "writeResultsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(GCFSWriteResult),
        .number = GCFSCommitResponse_FieldNumber_WriteResultsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GCFSCommitResponse__storage_, writeResultsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "commitTime",
        .dataTypeSpecific.className = GPBStringifySymbol(GPBTimestamp),
        .number = GCFSCommitResponse_FieldNumber_CommitTime,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GCFSCommitResponse__storage_, commitTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GCFSCommitResponse class]
                                     rootClass:[GCFSFirestoreRoot class]
                                          file:GCFSFirestoreRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GCFSCommitResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GCFSRollbackRequest

@implementation GCFSRollbackRequest

@dynamic database;
@dynamic transaction;

typedef struct GCFSRollbackRequest__storage_ {
  uint32_t _has_storage_[1];
  NSString *database;
  NSData *transaction;
} GCFSRollbackRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "database",
        .dataTypeSpecific.className = NULL,
        .number = GCFSRollbackRequest_FieldNumber_Database,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GCFSRollbackRequest__storage_, database),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "transaction",
        .dataTypeSpecific.className = NULL,
        .number = GCFSRollbackRequest_FieldNumber_Transaction,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GCFSRollbackRequest__storage_, transaction),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GCFSRollbackRequest class]
                                     rootClass:[GCFSFirestoreRoot class]
                                          file:GCFSFirestoreRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GCFSRollbackRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GCFSRunQueryRequest

@implementation GCFSRunQueryRequest

@dynamic queryTypeOneOfCase;
@dynamic consistencySelectorOneOfCase;
@dynamic parent;
@dynamic structuredQuery;
@dynamic transaction;
@dynamic newTransaction;
@dynamic readTime;

typedef struct GCFSRunQueryRequest__storage_ {
  uint32_t _has_storage_[3];
  NSString *parent;
  GCFSStructuredQuery *structuredQuery;
  NSData *transaction;
  GCFSTransactionOptions *newTransaction;
  GPBTimestamp *readTime;
} GCFSRunQueryRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "parent",
        .dataTypeSpecific.className = NULL,
        .number = GCFSRunQueryRequest_FieldNumber_Parent,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GCFSRunQueryRequest__storage_, parent),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "structuredQuery",
        .dataTypeSpecific.className = GPBStringifySymbol(GCFSStructuredQuery),
        .number = GCFSRunQueryRequest_FieldNumber_StructuredQuery,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(GCFSRunQueryRequest__storage_, structuredQuery),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "transaction",
        .dataTypeSpecific.className = NULL,
        .number = GCFSRunQueryRequest_FieldNumber_Transaction,
        .hasIndex = -2,
        .offset = (uint32_t)offsetof(GCFSRunQueryRequest__storage_, transaction),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "newTransaction",
        .dataTypeSpecific.className = GPBStringifySymbol(GCFSTransactionOptions),
        .number = GCFSRunQueryRequest_FieldNumber_NewTransaction,
        .hasIndex = -2,
        .offset = (uint32_t)offsetof(GCFSRunQueryRequest__storage_, newTransaction),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "readTime",
        .dataTypeSpecific.className = GPBStringifySymbol(GPBTimestamp),
        .number = GCFSRunQueryRequest_FieldNumber_ReadTime,
        .hasIndex = -2,
        .offset = (uint32_t)offsetof(GCFSRunQueryRequest__storage_, readTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GCFSRunQueryRequest class]
                                     rootClass:[GCFSFirestoreRoot class]
                                          file:GCFSFirestoreRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GCFSRunQueryRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    static const char *oneofs[] = {
      "queryType",
      "consistencySelector",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void GCFSRunQueryRequest_ClearQueryTypeOneOfCase(GCFSRunQueryRequest *message) {
  GPBDescriptor *descriptor = [message descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBMaybeClearOneof(message, oneof, -1, 0);
}
void GCFSRunQueryRequest_ClearConsistencySelectorOneOfCase(GCFSRunQueryRequest *message) {
  GPBDescriptor *descriptor = [message descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:1];
  GPBMaybeClearOneof(message, oneof, -2, 0);
}
#pragma mark - GCFSRunQueryResponse

@implementation GCFSRunQueryResponse

@dynamic transaction;
@dynamic hasDocument, document;
@dynamic hasReadTime, readTime;
@dynamic skippedResults;

typedef struct GCFSRunQueryResponse__storage_ {
  uint32_t _has_storage_[1];
  int32_t skippedResults;
  GCFSDocument *document;
  NSData *transaction;
  GPBTimestamp *readTime;
} GCFSRunQueryResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "document",
        .dataTypeSpecific.className = GPBStringifySymbol(GCFSDocument),
        .number = GCFSRunQueryResponse_FieldNumber_Document,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GCFSRunQueryResponse__storage_, document),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "transaction",
        .dataTypeSpecific.className = NULL,
        .number = GCFSRunQueryResponse_FieldNumber_Transaction,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GCFSRunQueryResponse__storage_, transaction),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "readTime",
        .dataTypeSpecific.className = GPBStringifySymbol(GPBTimestamp),
        .number = GCFSRunQueryResponse_FieldNumber_ReadTime,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GCFSRunQueryResponse__storage_, readTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "skippedResults",
        .dataTypeSpecific.className = NULL,
        .number = GCFSRunQueryResponse_FieldNumber_SkippedResults,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(GCFSRunQueryResponse__storage_, skippedResults),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GCFSRunQueryResponse class]
                                     rootClass:[GCFSFirestoreRoot class]
                                          file:GCFSFirestoreRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GCFSRunQueryResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GCFSWriteRequest

@implementation GCFSWriteRequest

@dynamic database;
@dynamic streamId;
@dynamic writesArray, writesArray_Count;
@dynamic streamToken;
@dynamic labels, labels_Count;

typedef struct GCFSWriteRequest__storage_ {
  uint32_t _has_storage_[1];
  NSString *database;
  NSString *streamId;
  NSMutableArray *writesArray;
  NSData *streamToken;
  NSMutableDictionary *labels;
} GCFSWriteRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "database",
        .dataTypeSpecific.className = NULL,
        .number = GCFSWriteRequest_FieldNumber_Database,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GCFSWriteRequest__storage_, database),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "streamId",
        .dataTypeSpecific.className = NULL,
        .number = GCFSWriteRequest_FieldNumber_StreamId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GCFSWriteRequest__storage_, streamId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "writesArray",
        .dataTypeSpecific.className = GPBStringifySymbol(GCFSWrite),
        .number = GCFSWriteRequest_FieldNumber_WritesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GCFSWriteRequest__storage_, writesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "streamToken",
        .dataTypeSpecific.className = NULL,
        .number = GCFSWriteRequest_FieldNumber_StreamToken,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GCFSWriteRequest__storage_, streamToken),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "labels",
        .dataTypeSpecific.className = NULL,
        .number = GCFSWriteRequest_FieldNumber_Labels,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GCFSWriteRequest__storage_, labels),
        .flags = GPBFieldMapKeyString,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GCFSWriteRequest class]
                                     rootClass:[GCFSFirestoreRoot class]
                                          file:GCFSFirestoreRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GCFSWriteRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GCFSWriteResponse

@implementation GCFSWriteResponse

@dynamic streamId;
@dynamic streamToken;
@dynamic writeResultsArray, writeResultsArray_Count;
@dynamic hasCommitTime, commitTime;

typedef struct GCFSWriteResponse__storage_ {
  uint32_t _has_storage_[1];
  NSString *streamId;
  NSData *streamToken;
  NSMutableArray *writeResultsArray;
  GPBTimestamp *commitTime;
} GCFSWriteResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "streamId",
        .dataTypeSpecific.className = NULL,
        .number = GCFSWriteResponse_FieldNumber_StreamId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GCFSWriteResponse__storage_, streamId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "streamToken",
        .dataTypeSpecific.className = NULL,
        .number = GCFSWriteResponse_FieldNumber_StreamToken,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GCFSWriteResponse__storage_, streamToken),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "writeResultsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(GCFSWriteResult),
        .number = GCFSWriteResponse_FieldNumber_WriteResultsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GCFSWriteResponse__storage_, writeResultsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "commitTime",
        .dataTypeSpecific.className = GPBStringifySymbol(GPBTimestamp),
        .number = GCFSWriteResponse_FieldNumber_CommitTime,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GCFSWriteResponse__storage_, commitTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GCFSWriteResponse class]
                                     rootClass:[GCFSFirestoreRoot class]
                                          file:GCFSFirestoreRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GCFSWriteResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GCFSListenRequest

@implementation GCFSListenRequest

@dynamic targetChangeOneOfCase;
@dynamic database;
@dynamic addTarget;
@dynamic removeTarget;
@dynamic labels, labels_Count;

typedef struct GCFSListenRequest__storage_ {
  uint32_t _has_storage_[2];
  int32_t removeTarget;
  NSString *database;
  GCFSTarget *addTarget;
  NSMutableDictionary *labels;
} GCFSListenRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "database",
        .dataTypeSpecific.className = NULL,
        .number = GCFSListenRequest_FieldNumber_Database,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GCFSListenRequest__storage_, database),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "addTarget",
        .dataTypeSpecific.className = GPBStringifySymbol(GCFSTarget),
        .number = GCFSListenRequest_FieldNumber_AddTarget,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(GCFSListenRequest__storage_, addTarget),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "removeTarget",
        .dataTypeSpecific.className = NULL,
        .number = GCFSListenRequest_FieldNumber_RemoveTarget,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(GCFSListenRequest__storage_, removeTarget),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "labels",
        .dataTypeSpecific.className = NULL,
        .number = GCFSListenRequest_FieldNumber_Labels,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GCFSListenRequest__storage_, labels),
        .flags = GPBFieldMapKeyString,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GCFSListenRequest class]
                                     rootClass:[GCFSFirestoreRoot class]
                                          file:GCFSFirestoreRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GCFSListenRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    static const char *oneofs[] = {
      "targetChange",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void GCFSListenRequest_ClearTargetChangeOneOfCase(GCFSListenRequest *message) {
  GPBDescriptor *descriptor = [message descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBMaybeClearOneof(message, oneof, -1, 0);
}
#pragma mark - GCFSListenResponse

@implementation GCFSListenResponse

@dynamic responseTypeOneOfCase;
@dynamic targetChange;
@dynamic documentChange;
@dynamic documentDelete;
@dynamic documentRemove;
@dynamic filter;

typedef struct GCFSListenResponse__storage_ {
  uint32_t _has_storage_[2];
  GCFSTargetChange *targetChange;
  GCFSDocumentChange *documentChange;
  GCFSDocumentDelete *documentDelete;
  GCFSExistenceFilter *filter;
  GCFSDocumentRemove *documentRemove;
} GCFSListenResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "targetChange",
        .dataTypeSpecific.className = GPBStringifySymbol(GCFSTargetChange),
        .number = GCFSListenResponse_FieldNumber_TargetChange,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(GCFSListenResponse__storage_, targetChange),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "documentChange",
        .dataTypeSpecific.className = GPBStringifySymbol(GCFSDocumentChange),
        .number = GCFSListenResponse_FieldNumber_DocumentChange,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(GCFSListenResponse__storage_, documentChange),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "documentDelete",
        .dataTypeSpecific.className = GPBStringifySymbol(GCFSDocumentDelete),
        .number = GCFSListenResponse_FieldNumber_DocumentDelete,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(GCFSListenResponse__storage_, documentDelete),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "filter",
        .dataTypeSpecific.className = GPBStringifySymbol(GCFSExistenceFilter),
        .number = GCFSListenResponse_FieldNumber_Filter,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(GCFSListenResponse__storage_, filter),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "documentRemove",
        .dataTypeSpecific.className = GPBStringifySymbol(GCFSDocumentRemove),
        .number = GCFSListenResponse_FieldNumber_DocumentRemove,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(GCFSListenResponse__storage_, documentRemove),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GCFSListenResponse class]
                                     rootClass:[GCFSFirestoreRoot class]
                                          file:GCFSFirestoreRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GCFSListenResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    static const char *oneofs[] = {
      "responseType",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void GCFSListenResponse_ClearResponseTypeOneOfCase(GCFSListenResponse *message) {
  GPBDescriptor *descriptor = [message descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBMaybeClearOneof(message, oneof, -1, 0);
}
#pragma mark - GCFSTarget

@implementation GCFSTarget

@dynamic targetTypeOneOfCase;
@dynamic resumeTypeOneOfCase;
@dynamic query;
@dynamic documents;
@dynamic resumeToken;
@dynamic readTime;
@dynamic targetId;
@dynamic once;

typedef struct GCFSTarget__storage_ {
  uint32_t _has_storage_[3];
  int32_t targetId;
  GCFSTarget_QueryTarget *query;
  GCFSTarget_DocumentsTarget *documents;
  NSData *resumeToken;
  GPBTimestamp *readTime;
} GCFSTarget__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "query",
        .dataTypeSpecific.className = GPBStringifySymbol(GCFSTarget_QueryTarget),
        .number = GCFSTarget_FieldNumber_Query,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(GCFSTarget__storage_, query),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "documents",
        .dataTypeSpecific.className = GPBStringifySymbol(GCFSTarget_DocumentsTarget),
        .number = GCFSTarget_FieldNumber_Documents,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(GCFSTarget__storage_, documents),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "resumeToken",
        .dataTypeSpecific.className = NULL,
        .number = GCFSTarget_FieldNumber_ResumeToken,
        .hasIndex = -2,
        .offset = (uint32_t)offsetof(GCFSTarget__storage_, resumeToken),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "targetId",
        .dataTypeSpecific.className = NULL,
        .number = GCFSTarget_FieldNumber_TargetId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GCFSTarget__storage_, targetId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "once",
        .dataTypeSpecific.className = NULL,
        .number = GCFSTarget_FieldNumber_Once,
        .hasIndex = 1,
        .offset = 2,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "readTime",
        .dataTypeSpecific.className = GPBStringifySymbol(GPBTimestamp),
        .number = GCFSTarget_FieldNumber_ReadTime,
        .hasIndex = -2,
        .offset = (uint32_t)offsetof(GCFSTarget__storage_, readTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GCFSTarget class]
                                     rootClass:[GCFSFirestoreRoot class]
                                          file:GCFSFirestoreRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GCFSTarget__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    static const char *oneofs[] = {
      "targetType",
      "resumeType",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void GCFSTarget_ClearTargetTypeOneOfCase(GCFSTarget *message) {
  GPBDescriptor *descriptor = [message descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBMaybeClearOneof(message, oneof, -1, 0);
}
void GCFSTarget_ClearResumeTypeOneOfCase(GCFSTarget *message) {
  GPBDescriptor *descriptor = [message descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:1];
  GPBMaybeClearOneof(message, oneof, -2, 0);
}
#pragma mark - GCFSTarget_DocumentsTarget

@implementation GCFSTarget_DocumentsTarget

@dynamic documentsArray, documentsArray_Count;

typedef struct GCFSTarget_DocumentsTarget__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *documentsArray;
} GCFSTarget_DocumentsTarget__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "documentsArray",
        .dataTypeSpecific.className = NULL,
        .number = GCFSTarget_DocumentsTarget_FieldNumber_DocumentsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GCFSTarget_DocumentsTarget__storage_, documentsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GCFSTarget_DocumentsTarget class]
                                     rootClass:[GCFSFirestoreRoot class]
                                          file:GCFSFirestoreRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GCFSTarget_DocumentsTarget__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(GCFSTarget)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GCFSTarget_QueryTarget

@implementation GCFSTarget_QueryTarget

@dynamic queryTypeOneOfCase;
@dynamic parent;
@dynamic structuredQuery;

typedef struct GCFSTarget_QueryTarget__storage_ {
  uint32_t _has_storage_[2];
  NSString *parent;
  GCFSStructuredQuery *structuredQuery;
} GCFSTarget_QueryTarget__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "parent",
        .dataTypeSpecific.className = NULL,
        .number = GCFSTarget_QueryTarget_FieldNumber_Parent,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GCFSTarget_QueryTarget__storage_, parent),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "structuredQuery",
        .dataTypeSpecific.className = GPBStringifySymbol(GCFSStructuredQuery),
        .number = GCFSTarget_QueryTarget_FieldNumber_StructuredQuery,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(GCFSTarget_QueryTarget__storage_, structuredQuery),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GCFSTarget_QueryTarget class]
                                     rootClass:[GCFSFirestoreRoot class]
                                          file:GCFSFirestoreRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GCFSTarget_QueryTarget__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    static const char *oneofs[] = {
      "queryType",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(GCFSTarget)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void GCFSTarget_QueryTarget_ClearQueryTypeOneOfCase(GCFSTarget_QueryTarget *message) {
  GPBDescriptor *descriptor = [message descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBMaybeClearOneof(message, oneof, -1, 0);
}
#pragma mark - GCFSTargetChange

@implementation GCFSTargetChange

@dynamic targetChangeType;
@dynamic targetIdsArray, targetIdsArray_Count;
@dynamic hasCause, cause;
@dynamic resumeToken;
@dynamic hasReadTime, readTime;

typedef struct GCFSTargetChange__storage_ {
  uint32_t _has_storage_[1];
  GCFSTargetChange_TargetChangeType targetChangeType;
  GPBInt32Array *targetIdsArray;
  RPCStatus *cause;
  NSData *resumeToken;
  GPBTimestamp *readTime;
} GCFSTargetChange__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "targetChangeType",
        .dataTypeSpecific.enumDescFunc = GCFSTargetChange_TargetChangeType_EnumDescriptor,
        .number = GCFSTargetChange_FieldNumber_TargetChangeType,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GCFSTargetChange__storage_, targetChangeType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "targetIdsArray",
        .dataTypeSpecific.className = NULL,
        .number = GCFSTargetChange_FieldNumber_TargetIdsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GCFSTargetChange__storage_, targetIdsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "cause",
        .dataTypeSpecific.className = GPBStringifySymbol(RPCStatus),
        .number = GCFSTargetChange_FieldNumber_Cause,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GCFSTargetChange__storage_, cause),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "resumeToken",
        .dataTypeSpecific.className = NULL,
        .number = GCFSTargetChange_FieldNumber_ResumeToken,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GCFSTargetChange__storage_, resumeToken),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "readTime",
        .dataTypeSpecific.className = GPBStringifySymbol(GPBTimestamp),
        .number = GCFSTargetChange_FieldNumber_ReadTime,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(GCFSTargetChange__storage_, readTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GCFSTargetChange class]
                                     rootClass:[GCFSFirestoreRoot class]
                                          file:GCFSFirestoreRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GCFSTargetChange__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t GCFSTargetChange_TargetChangeType_RawValue(GCFSTargetChange *message) {
  GPBDescriptor *descriptor = [GCFSTargetChange descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:GCFSTargetChange_FieldNumber_TargetChangeType];
  return GPBGetMessageInt32Field(message, field);
}

void SetGCFSTargetChange_TargetChangeType_RawValue(GCFSTargetChange *message, int32_t value) {
  GPBDescriptor *descriptor = [GCFSTargetChange descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:GCFSTargetChange_FieldNumber_TargetChangeType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum GCFSTargetChange_TargetChangeType

GPBEnumDescriptor *GCFSTargetChange_TargetChangeType_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "NoChange\000Add\000Remove\000Current\000Reset\000";
    static const int32_t values[] = {
        GCFSTargetChange_TargetChangeType_NoChange,
        GCFSTargetChange_TargetChangeType_Add,
        GCFSTargetChange_TargetChangeType_Remove,
        GCFSTargetChange_TargetChangeType_Current,
        GCFSTargetChange_TargetChangeType_Reset,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(GCFSTargetChange_TargetChangeType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:GCFSTargetChange_TargetChangeType_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL GCFSTargetChange_TargetChangeType_IsValidValue(int32_t value__) {
  switch (value__) {
    case GCFSTargetChange_TargetChangeType_NoChange:
    case GCFSTargetChange_TargetChangeType_Add:
    case GCFSTargetChange_TargetChangeType_Remove:
    case GCFSTargetChange_TargetChangeType_Current:
    case GCFSTargetChange_TargetChangeType_Reset:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - GCFSListCollectionIdsRequest

@implementation GCFSListCollectionIdsRequest

@dynamic parent;
@dynamic pageSize;
@dynamic pageToken;

typedef struct GCFSListCollectionIdsRequest__storage_ {
  uint32_t _has_storage_[1];
  int32_t pageSize;
  NSString *parent;
  NSString *pageToken;
} GCFSListCollectionIdsRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "parent",
        .dataTypeSpecific.className = NULL,
        .number = GCFSListCollectionIdsRequest_FieldNumber_Parent,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GCFSListCollectionIdsRequest__storage_, parent),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "pageSize",
        .dataTypeSpecific.className = NULL,
        .number = GCFSListCollectionIdsRequest_FieldNumber_PageSize,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GCFSListCollectionIdsRequest__storage_, pageSize),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "pageToken",
        .dataTypeSpecific.className = NULL,
        .number = GCFSListCollectionIdsRequest_FieldNumber_PageToken,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GCFSListCollectionIdsRequest__storage_, pageToken),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GCFSListCollectionIdsRequest class]
                                     rootClass:[GCFSFirestoreRoot class]
                                          file:GCFSFirestoreRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GCFSListCollectionIdsRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GCFSListCollectionIdsResponse

@implementation GCFSListCollectionIdsResponse

@dynamic collectionIdsArray, collectionIdsArray_Count;
@dynamic nextPageToken;

typedef struct GCFSListCollectionIdsResponse__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *collectionIdsArray;
  NSString *nextPageToken;
} GCFSListCollectionIdsResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "collectionIdsArray",
        .dataTypeSpecific.className = NULL,
        .number = GCFSListCollectionIdsResponse_FieldNumber_CollectionIdsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GCFSListCollectionIdsResponse__storage_, collectionIdsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "nextPageToken",
        .dataTypeSpecific.className = NULL,
        .number = GCFSListCollectionIdsResponse_FieldNumber_NextPageToken,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GCFSListCollectionIdsResponse__storage_, nextPageToken),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GCFSListCollectionIdsResponse class]
                                     rootClass:[GCFSFirestoreRoot class]
                                          file:GCFSFirestoreRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GCFSListCollectionIdsResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
